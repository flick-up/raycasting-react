{"version":3,"sources":["lib/point.js","components/map.jsx","lib/radians.js","components/mini-map.jsx","lib/ray.js","lib/player.js","components/grid-column.jsx","components/scene.jsx","hooks/with-use-key-pressed.js","hooks/with-use-immutable-state.js","hooks/with-use-animation-frame.js","components/application.jsx","index.js","hooks/with-use-cast-rays.js"],"names":["Point","x","y","this","Map","height","size","grid","toGrid","point","units","Math","floor","prototype","add","distance","anotherDistance","hypot","isWall","gridCoordinates","isWithinCoordinateBounds","twoPi","PI","fromDegrees","degrees","Minimap","wallsRef","React","createRef","playerRef","raysRef","drawWalls","drawPlayer","drawRays","context","current","getContext","props","map","cellSize","fillStyle","forEach","row","cell","fillRect","player","position","gridX","gridY","minimapX","minimapY","clearRect","beginPath","arc","fill","rays","strokeStyle","i","length","angle","origin","gridDistance","mapDistance","moveTo","lineTo","cos","sin","stroke","prevProps","style","styles","container","ref","width","layer","Component","top","left","boxShadow","Ray","radians","newAngle","normalize","up","right","horizontalDistance","intersectionY","intersection","tan","deltaY","deltaX","abs","findWall","castHorizontal","verticalDistance","intersectionX","castVertical","min","cast","Infinity","Player","direction","adjustDelta","wall","delta","castRays","fov","resolution","angleBetween","start","Array","_","index","turnRight","time","turnLeft","moveForward","dX","dY","moveBackward","dx","dy","moveLeft","moveRight","Column","color","mapHeight","number","screenHeight","screenWidth","backgroundColor","Color","darken","hex","Scene","containerStyles","useMemo","ceiling","ray","adjustDistance","key","border","borderRadius","display","alignItems","justifyContent","borderTopLeftRadius","borderTopRightRadius","bottom","borderBottomLeftRadius","borderBottomRightRadius","reducer","state","action","type","useKeyPressing","handlers","andThen","initialState","useReducer","dispatch","stateRef","useRef","useEffect","useImmutableStateReducer","callback","frameRef","timestampRef","window","performance","now","requestAnimationFrame","loop","timestamp","cancelAnimationFrame","useAnimationFrame","useCallback","elapsed","isPressingKey","value","keyNames","Object","keys","handleKeyDown","event","includes","code","preventDefault","handleKeyUp","document","addEventListener","removeEventListener","ApplicationMap","flexDirection","paddingTop","ReactDOM","render","createElement","useState","showMinimap","setShowMinimap","setRays","newRays","KeyW","KeyS","KeyA","KeyD","ArrowLeft","ArrowRight","useCastRays","htmlFor","id","onChange","checked","getElementById"],"mappings":"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","file":"static/js/main.6f21f74f.chunk.js","sourcesContent":["\r\nexport default function Point(x, y){\r\n  this.x = x;\r\n  this.y = y;\r\n}\r\n\r\nPoint.prototype.add = function(x, y){\r\n  return new Point(this.x + x, this.y + y);\r\n};\r\n\r\nPoint.prototype.distance = function (anotherDistance){\r\n  return Math.hypot(this.x - anotherDistance.x, this.y - anotherDistance.y);\r\n};\r\n","import Point from 'lib/point';\r\nexport default function Map(height) {\r\n  this.height = height;\r\n  this.size = 10;\r\n  this.grid = [\r\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],\r\n    [1, 0, 0, 0, 1, 1, 1, 1, 0, 1],\r\n    [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],\r\n    [1, 0, 0, 0, 0, 1, 0, 1, 0, 1],\r\n    [1, 0, 0, 0, 0, 1, 1, 1, 0, 1],\r\n    [1, 0, 1, 0, 0, 0, 0, 0, 0, 1],\r\n    [1, 0, 1, 1, 0, 0, 0, 0, 0, 1],\r\n    [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],\r\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n  ];\r\n}\r\n\r\nMap.prototype.isWall = function (point) {\r\n  const gridCoordinates = toGrid(point, this.height);\r\n  return this.isWithinCoordinateBounds(point) && this.grid[gridCoordinates.y][gridCoordinates.x] === 1;\r\n};\r\n\r\nMap.prototype.isWithinCoordinateBounds = function (point) {\r\n  const gridCoordinates = toGrid(point, this.height);\r\n  return gridCoordinates.x >= 0 && gridCoordinates.x < this.size && gridCoordinates.y >= 0 && gridCoordinates.y < this.size;\r\n};\r\n\r\n// Convert unit coordinates to grid coordinates. Each grid coordinate can be broken up into\r\n// some number of smaller \"unit\" coordinates.\r\nfunction toGrid(point, units) {\r\n  return new Point(Math.floor(point.x / units), Math.floor(point.y / units));\r\n}\r\n","export const twoPi = 2 * Math.PI;\r\n\r\n// Convert degrees to radians.\r\nexport function fromDegrees(degrees) {\r\n  return degrees * Math.PI / 180;\r\n}\r\n\r\n// Ensure that radians are between 0 and 2π.\r\nexport function normalize(radians) {\r\n  const newAngle = radians % twoPi;\r\n  return newAngle < 0 ? newAngle + twoPi : newAngle;\r\n}\r\n","import React from 'react';\r\nimport { twoPi } from 'lib/radians';\r\n\r\n\r\nexport default class Minimap extends React.Component {\r\n  wallsRef = React.createRef()\r\n  playerRef = React.createRef()\r\n  raysRef = React.createRef()\r\n\r\n  componentDidMount() {\r\n    this.drawWalls();\r\n    this.drawPlayer();\r\n    this.drawRays();\r\n  }\r\n\r\n  drawWalls() {\r\n    const context = this.wallsRef.current.getContext('2d');\r\n    const { map, size } = this.props;\r\n    const cellSize = size / map.size;\r\n\r\n    context.fillStyle = '#212121';\r\n\r\n    map.grid.forEach((row, y) => {\r\n      row.forEach((cell, x) => {\r\n        if (cell === 1) {\r\n          context.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  drawPlayer() {\r\n    const context = this.playerRef.current.getContext('2d');\r\n    const { map, player, size } = this.props;\r\n    const { position } = player;\r\n    const gridX = position.x / map.height;\r\n    const gridY = position.y / map.height;\r\n    const cellSize = size / map.size;\r\n    const minimapX = gridX * cellSize;\r\n    const minimapY = gridY * cellSize;\r\n\r\n    context.clearRect(0, 0, size, size);\r\n    context.fillStyle = 'black';\r\n    context.beginPath();\r\n    context.arc(minimapX, minimapY, 5, 0, twoPi);\r\n    context.fill();\r\n  }\r\n\r\n  drawRays() {\r\n    const context = this.raysRef.current.getContext('2d');\r\n    const { map, rays, size } = this.props;\r\n    const cellSize = size / map.size;\r\n\r\n    context.clearRect(0, 0, size, size);\r\n    context.beginPath();\r\n    context.strokeStyle = '#424242';\r\n\r\n    for (let i = 0; i < rays.length; i += 16) {\r\n      const { angle, distance, origin } = rays[i];\r\n      const gridX = origin.x / map.height;\r\n      const gridY = origin.y / map.height;\r\n      const gridDistance = distance / map.height;\r\n      const minimapX = gridX * cellSize;\r\n      const minimapY = gridY * cellSize;\r\n      const mapDistance = (size / map.size) * gridDistance;\r\n\r\n      context.moveTo(minimapX, minimapY);\r\n      context.lineTo(minimapX + mapDistance * Math.cos(angle), minimapY + mapDistance * -Math.sin(angle));\r\n      context.stroke();\r\n    }\r\n  }\r\n\r\n  componentDidUpdate(prevProps) {\r\n    if (prevProps.rays !== this.props.rays) {\r\n      this.drawPlayer();\r\n      this.drawRays();\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const { size } = this.props;\r\n    return (\r\n      <div style={styles.container}>\r\n        <canvas ref={this.wallsRef} height={size} width={size} style={styles.layer} />\r\n        <canvas ref={this.playerRef} height={size} width={size} style={styles.layer} />\r\n        <canvas ref={this.raysRef} height={size} width={size} style={styles.layer} />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nconst styles = {\r\n  container: {\r\n    position: 'absolute',\r\n    top: '35%',\r\n    left: '40px',\r\n  },\r\n  layer: {\r\n    position: 'absolute',\r\n    boxShadow: '0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12), 0 2px 4px -1px rgba(0, 0, 0, 0.3)',\r\n    top: 0,\r\n    left: 0,\r\n  },\r\n};\r\n","import Point from 'lib/point';\r\nimport { normalize, twoPi } from 'lib/radians'\r\n\r\nexport default function Ray(map, angle, origin) {\r\n  this.origin = origin;\r\n  this.angle = normalize(angle);\r\n  this.distance = cast(map, this.angle, origin);\r\n}\r\n\r\n// Determine the distance travelled before hitting a wall.\r\nfunction cast(map, angle, origin) {\r\n  // Determine the direction the ray is travelling.\r\n  const up = angle > 0 && angle < Math.PI;\r\n  const right = angle < (twoPi * 0.25) || angle > (twoPi * 0.75);\r\n\r\n  // Determine the distance to the first horizontal wall.\r\n  const horizontalDistance = castHorizontal(map, origin, angle, up, right);\r\n\r\n  // Determine the distance to the first vertical wall.\r\n  const verticalDistance = castVertical(map, origin, angle, up, right);\r\n\r\n  // Return the shortest distance between the horizontal and vertical distances.\r\n  return Math.min(horizontalDistance, verticalDistance);\r\n}\r\n\r\n// Determine the distance travelled before hitting a _horizontal_ wall.\r\nfunction castHorizontal(map, origin, angle, up, right) {\r\n  // Calculate the coordinates of the first intersection with a grid boundary.\r\n  const intersectionY = Math.floor(origin.y / map.height) * map.height + (up ? -0.01 : map.height);\r\n  const intersectionX = origin.x + (origin.y - intersectionY) / Math.tan(angle);\r\n  const intersection = new Point(intersectionX, intersectionY);\r\n\r\n  // Calculate the change in x and y coordinates needed to iterate across grid boundaries.\r\n  const deltaY = up ? -map.height : map.height;\r\n  const deltaX = Math.abs(map.height / Math.tan(angle)) * (right ? 1 : -1);\r\n\r\n  // Find the nearest wall and return the distance to it.\r\n  const wall = findWall(map, intersection, deltaX, deltaY);\r\n  return wall.distance(origin);\r\n}\r\n\r\n// Determine the distance travelled before hitting a _vertical_ wall.\r\nfunction castVertical(map, origin, angle, up, right) {\r\n  // Calculate the coordinates of the first intersection with a grid boundary.\r\n  const intersectionX = Math.floor(origin.x / map.height) * map.height + (right ? map.height : -0.01);\r\n  const intersectionY = origin.y + (origin.x - intersectionX) * Math.tan(angle);\r\n  const intersection = new Point(intersectionX, intersectionY);\r\n\r\n  // Calculate the change in x and y coordinates needed to iterate across grid boundaries.\r\n  const deltaX = right ? map.height : -map.height;\r\n  const deltaY = Math.abs(map.height * Math.tan(angle)) * (up ? -1 : 1);\r\n\r\n  // Find the nearest wall and return the distance to it.\r\n  const wall = findWall(map, intersection, deltaX, deltaY);\r\n  return wall.distance(origin);\r\n}\r\n\r\n// Process each step the ray takes until encountering a wall or the bounds of the map.\r\nfunction findWall(map, position, deltaX, deltaY) {\r\n  // If the ray is no longer within the bounds of the map, return a point infinitely far away.\r\n  if (!map.isWithinCoordinateBounds(position)) {\r\n    return new Point(Infinity, Infinity);\r\n  }\r\n\r\n  // If the ray has hit a wall, return its position.\r\n  if (map.isWall(position)) {\r\n    return position;\r\n  }\r\n\r\n  // No wall has been encountered. Iterate to the next grid boundary and check again.\r\n  return findWall(map, position.add(deltaX, deltaY), deltaX, deltaY);\r\n}\r\n","import Point from 'lib/point';\r\nimport Ray from 'lib/ray';\r\n\r\nconst stepdist = 1.4;\r\nconst rotateSpeed = 0.025;\r\n\r\nexport default function Player(x, y, direction){\r\n  this.position = new Point(x, y);\r\n  this.direction = direction;\r\n}\r\n\r\n// Determine the distance to nearby walls the user is able to see\r\n// by casting rays.\r\n\r\n// The resolution being the number of rays to cast\r\n// The field of view etc\r\n\r\nPlayer.prototype.castRays = function (map, fov, resolution){\r\n  // If FOV is 60 and res = 320, there is 60 / 320 degrees between\r\n  // the rays\r\n  const angleBetween = fov / resolution;\r\n\r\n  // Players direction is the center of the screen. Left edge of the screen is\r\n  // half the field of view to the left\r\n  // Angle increases as you turn counter-clockwise. Add to players current direction\r\n  const start = this.direction + fov / 2;\r\n\r\n  // Create an array of angle for each ray from left sweeping to the right of screen\r\n  // edge\r\n  const angles = new Array(resolution).fill(0).map((_, index) => start - index * angleBetween);\r\n\r\n  return angles.map(angle => new Ray(map, angle, this.position));\r\n};\r\n\r\nPlayer.prototype.turnRight = function (time) {\r\n  this.direction -= rotateSpeed * time / 16;\r\n};\r\n\r\nPlayer.prototype.turnLeft = function (time){\r\n  this.direction += rotateSpeed * time / 16;\r\n};\r\n\r\nPlayer.prototype.moveForward = function (map, time){\r\n  const dX = stepdist * (time / 16) * Math.cos(this.direction);\r\n  const dY = stepdist * (time / 16) * Math.sin(this.direction);\r\n\r\n  this.position = this.position.add(\r\n    adjustDelta(map, this.position.add(dX, 0), dX),\r\n    adjustDelta(map, this.position.add(0, -dY), -dY),\r\n  );\r\n};\r\n\r\nPlayer.prototype.moveBackward = function (map, time){\r\n  const dx = stepdist * (time / 16) * Math.cos(this.direction);\r\n  const dy = stepdist * (time / 16) * Math.sin(this.direction);\r\n\r\n  this.position = this.position.add(\r\n    adjustDelta(map, this.position.add(-dx, 0), -dx),\r\n    adjustDelta(map, this.position.add(0, dy), dy),\r\n  );\r\n};\r\n\r\n// Step to the left, same as stepping forward but rotated 90 deg to the left\r\nPlayer.prototype.moveLeft = function (map, time){\r\n  const dx = stepdist * (time / 16) * Math.cos(this.direction + Math.PI / 2);\r\n  const dy = stepdist * (time / 16) * Math.sin(this.direction + Math.PI / 2);\r\n\r\n   this.position = this.position.add(\r\n     adjustDelta(map, this.position.add(dx, 0), dx),\r\n     adjustDelta(map, this.position.add(0, -dy), -dy),\r\n   );\r\n};\r\n\r\n// Step to the right, which is the same as stepping backward but rotated 90 degrees to the left.\r\nPlayer.prototype.moveRight = function (map, time){\r\n  const dx = stepdist * (time / 16) * Math.cos(this.direction + Math.PI / 2);\r\n  const dy = stepdist * (time / 16) * Math.sin(this.direction + Math.PI / 2);\r\n\r\n   this.position = this.position.add(\r\n     adjustDelta(map, this.position.add(-dx, 0), -dx),\r\n     adjustDelta(map, this.position.add(0, dy), dy),\r\n   );\r\n};\r\n\r\nfunction adjustDelta(map, wall, delta){\r\n  return map.isWall(wall) ? 0 : delta;\r\n}\r\n","import Color from 'color';\r\nimport React from 'react';\r\n\r\nexport default function Column({\r\n  color,\r\n  distance,\r\n  mapHeight,\r\n  number,\r\n  resolution,\r\n  screenHeight,\r\n  screenWidth,\r\n}) {\r\n  const height = Math.min(mapHeight / distance * 255, screenHeight);\r\n  const width = screenWidth / resolution;\r\n  const top = (screenHeight - height) / 2;\r\n  const adjustedColor = Color(color).darken(distance / 460).hex();\r\n  const styles = {\r\n    backgroundColor: adjustedColor,\r\n    height,\r\n    left: number * width,\r\n    width,\r\n    position: 'absolute',\r\n    top,\r\n  };\r\n\r\n  return <div style={styles} />;\r\n}\r\n","import React, { useMemo } from 'react';\r\nimport Column from './grid-column';\r\n\r\nexport default function Scene({\r\n  height,\r\n  mapHeight,\r\n  player,\r\n  rays,\r\n  resolution,\r\n  width,\r\n}) {\r\n  const containerStyles = useMemo(() => ({ ...styles.container, height, width }), [height, width]);\r\n\r\n  return (\r\n    <div style={containerStyles}>\r\n      <div style={styles.ceiling} />\r\n      <div style={styles.floor} />\r\n      {rays.map((ray, index) => (\r\n        <Column\r\n          color=\"#424242\"\r\n          distance={adjustDistance(ray, player)}\r\n          key={index} // eslint-disable-line react/no-array-index-key\r\n          mapHeight={mapHeight}\r\n          number={index}\r\n          resolution={resolution}\r\n          screenHeight={height}\r\n          screenWidth={width}\r\n        />\r\n      ))}\r\n    </div>\r\n  );\r\n}\r\n\r\n// Correct for a fishbowl-effect resulting from mixing polar and cartesian coordinates.\r\nfunction adjustDistance(ray, player) {\r\n  return ray.distance * Math.cos(ray.angle - player.direction);\r\n}\r\n\r\nconst styles = {\r\n  container: {\r\n    border: '1.15px solid rgb(45,45,45)',\r\n    borderRadius: '6px',\r\n    boxShadow: '0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12), 0 2px 4px -1px rgba(0, 0, 0, 0.3)',\r\n    position: 'relative',\r\n    display: 'flex',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  },\r\n  ceiling: {\r\n    backgroundColor: '#e3f2fd',\r\n    borderTopLeftRadius: 'inherit',\r\n    borderTopRightRadius: 'inherit',\r\n    position: 'absolute',\r\n    left: 0,\r\n    right: 0,\r\n    bottom: '50%',\r\n    top: 0,\r\n  },\r\n  floor: {\r\n    backgroundColor: '#607d8b',\r\n    borderBottomLeftRadius: 'inherit',\r\n    borderBottomRightRadius: 'inherit',\r\n    position: 'absolute',\r\n    left: 0,\r\n    right: 0,\r\n    bottom: 0,\r\n    top: '50%',\r\n  },\r\n};\r\n","import forEach from 'lodash.foreach';\r\nimport { useCallback, useEffect } from 'react';\r\nimport useAnimationFrame from './with-use-animation-frame';\r\nimport useImmutableStateReducer from './with-use-immutable-state';\r\n\r\nfunction reducer(state, action) {\r\n  switch (action.type) {\r\n    case 'down':\r\n      return { ...state, [action.key]: true };\r\n    case 'up':\r\n      return { ...state, [action.key]: false };\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nexport default function useKeyPressing(handlers, { andThen = () => {} }) {\r\n  const [stateRef, dispatch] = useImmutableStateReducer(reducer, {});\r\n\r\n  useAnimationFrame(\r\n    useCallback(\r\n      (elapsed) => {\r\n        let isPressingKey = false;\r\n\r\n        // Execute the handler for all keys that are being pressed.\r\n        forEach(handlers, (value, key) => {\r\n          if (stateRef.current[key]) {\r\n            isPressingKey = true;\r\n            value(elapsed);\r\n          }\r\n        });\r\n\r\n        if (isPressingKey) { andThen(); }\r\n      },\r\n      [stateRef, handlers, andThen],\r\n    ),\r\n  );\r\n\r\n  useEffect(() => {\r\n    const keyNames = Object.keys(handlers);\r\n\r\n    function handleKeyDown(event) {\r\n      if (keyNames.includes(event.code)) {\r\n        event.preventDefault();\r\n        dispatch({ type: 'down', key: event.code });\r\n      }\r\n    }\r\n\r\n    function handleKeyUp(event) {\r\n      if (keyNames.includes(event.code)) {\r\n        event.preventDefault();\r\n        dispatch({ type: 'up', key: event.code });\r\n      }\r\n    }\r\n\r\n    document.addEventListener('keydown', handleKeyDown);\r\n    document.addEventListener('keyup', handleKeyUp);\r\n\r\n    return () => {\r\n      document.removeEventListener('keydown', handleKeyDown);\r\n      document.removeEventListener('keyup', handleKeyUp);\r\n    };\r\n  }, [handlers, dispatch]);\r\n}\r\n","import { useEffect, useReducer, useRef } from 'react';\r\n\r\nexport default function useImmutableStateReducer(reducer, initialState) {\r\n  const [state, dispatch] = useReducer(reducer, initialState);\r\n  const stateRef = useRef(state);\r\n\r\n  useEffect(() => {\r\n    stateRef.current = state;\r\n  }, [state]);\r\n\r\n  return [stateRef, dispatch];\r\n}\r\n","import { useEffect, useRef } from 'react';\r\n\r\nexport default function useAnimationFrame(callback) {\r\n  const frameRef = useRef();\r\n  const timestampRef = useRef();\r\n\r\n  useEffect(() => {\r\n    timestampRef.current = window.performance.now();\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    function loop(timestamp) {\r\n      frameRef.current = requestAnimationFrame(loop);\r\n      callback(timestamp - timestampRef.current);\r\n      timestampRef.current = timestamp;\r\n    };\r\n\r\n    frameRef.current = requestAnimationFrame(loop);\r\n    return () => cancelAnimationFrame(frameRef.current);\r\n  }, [callback]);\r\n};\r\n","import React, { useState } from 'react';\r\nimport ApplicationMap from 'components/map';\r\nimport Minimap from 'components/mini-map';\r\nimport Player from 'lib/player';\r\nimport Scene from 'components/scene';\r\nimport useCastRays from 'hooks/with-use-cast-rays';\r\nimport { fromDegrees } from 'lib/radians';\r\n\r\nconst fov = fromDegrees(60);\r\nconst map = new ApplicationMap(64);\r\nconst player = new Player(160, 160, fromDegrees(0));\r\nconst resolution = 320;\r\n\r\nexport default function Application(){\r\n  const [showMinimap, setShowMinimap] = useState(true);\r\n  const rays = useCastRays(player, map, fov, resolution);\r\n\r\n  return (\r\n    <div style={styles.container}>\r\n      <h3>Raycasting React Experiment</h3>\r\n      <div>\r\n        <Scene\r\n          height={480}\r\n          mapHeight={map.height}\r\n          player={player}\r\n          rays={rays}\r\n          resolution={resolution}\r\n          width={840}\r\n        />\r\n        <div>\r\n          <span>Move your player using the W, A, S, D, ←, and → Keys!</span>\r\n          <div>\r\n            <label htmlFor=\"show_minimap\">\r\n              Show minimap\r\n              <input id=\"show_minimap\" onChange={() => setShowMinimap(!showMinimap)} type=\"checkbox\" checked={showMinimap} />\r\n            </label>\r\n          </div>\r\n        {/*Show minimap*/}\r\n        </div>\r\n      </div>\r\n      {showMinimap && (\r\n        <Minimap\r\n          fov={fov}\r\n          map={map}\r\n          player={player}\r\n          rays={rays}\r\n          resolution={resolution}\r\n          size={250}\r\n        />\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nconst styles = {\r\n  container: {\r\n    display: 'flex',\r\n    flexDirection: 'column',\r\n    alignItems: 'center',\r\n    paddingTop: '50px',\r\n  },\r\n};\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport Application from 'components/application';\r\nimport './index.css';\r\n\r\nReactDOM.render(React.createElement(Application), document.getElementById('application-root'));\r\n","import { useCallback, useEffect, useMemo, useState } from 'react';\r\nimport useKeyPressing from './with-use-key-pressed';\r\n\r\nexport default function useCastRays(player, map, fov, resolution) {\r\n  const [rays, setRays] = useState([]);\r\n\r\n  const castRays = useCallback(() => {\r\n    const newRays = player.castRays(map, fov, resolution);\r\n    setRays(newRays);\r\n  }, [player, map, fov, resolution]);\r\n\r\n  useEffect(() => { castRays(); }, [castRays]);\r\n\r\n  useKeyPressing(\r\n    useMemo(\r\n      () => {\r\n        return {\r\n          KeyW: (elapsed) => { player.moveForward(map, elapsed); },\r\n          KeyS: (elapsed) => { player.moveBackward(map, elapsed); },\r\n          KeyA: (elapsed) => { player.moveLeft(map, elapsed); },\r\n          KeyD: (elapsed) => { player.moveRight(map, elapsed); },\r\n          ArrowLeft: (elapsed) => { player.turnLeft(elapsed); },\r\n          ArrowRight: (elapsed) => { player.turnRight(elapsed); },\r\n        };\r\n      },\r\n      [player, map],\r\n    ),\r\n    { andThen: castRays },\r\n  );\r\n\r\n  return rays;\r\n}\r\n"],"sourceRoot":""}